## ğŸ“š ë‚´ìš© ì •ë¦¬
---
### âœ¨ oracle JDKì˜ ìœ ë£Œí™”
- Java 11ì€ LTS ë²„ì „ì´ë‹¤. ìœ ë£Œí™” ì‹œì‘


### âœ¨ Java 11 ì— ì¶”ê°€ë˜ê±°ë‚˜ ê°œì„ ëœ ê¸°ëŠ¥ë“¤

| JEP | ì´ë¦„                                                           | ê´€ë ¨ í•­ëª© | í™•ì¸ í•„ìš” |
| --- | ------------------------------------------------------------ | ----- | ----- |
| 181 | Nest-Based Access Control                                    | ê¸°ëŠ¥ ê°œì„  |       |
| 309 | Dynamic Class-File Constants                                 | ê¸°ëŠ¥ ê°œì„  |       |
| 315 | Improve Aarch64 Intrinsics                                   | ê¸°ëŠ¥ ê°œì„  |       |
| 318 | Epsilon: A No-Op Garbage Collector                           | GC ê°œì„  |       |
| 320 | Remove the Java EE and CORBA Modules                         | ê¸°ëŠ¥ ì œê±° |       |
| 321 | HTTP Client (Standard)                                       | ê¸°ëŠ¥ ì¶”ê°€ |       |
| 323 | Local-Variable Syntax for Lambda Parameters                  | ê¸°ëŠ¥ ì¶”ê°€ |       |
| 324 | Key Agreement with Curve25519 and Curve448                   | ê¸°ëŠ¥ ì¶”ê°€ |       |
| 327 | Unicode 10                                                   | ê¸°ëŠ¥ ì¶”ê°€ |       |
| 328 | Flight Recorder                                              | ê¸°ëŠ¥ ê°œì„  |       |
| 329 | ChaCha20 and Poly1305 Cryptographic Algorithms               | ê¸°ëŠ¥ ì¶”ê°€ |       |
| 330 | Launch Single-File Source-Code Programs                      | ê¸°ëŠ¥ ì¶”ê°€ |       |
| 331 | Low-Overhead Heap Profiling                                  | ê¸°ëŠ¥ ê°œì„  |       |
| 332 | Transport Layer Security (TLS) 1.3                           | ê¸°ëŠ¥ ê°œì„  |       |
| 333 | ZGC: A Scalable Low-Latency Garbage Collector (Experimental) | ê¸°ëŠ¥ ì¶”ê°€ |       |
| 335 | Deprecate the Nashorn JavaScript Engine                      | ê¸°ëŠ¥ ê°œì„  |       |
| 336 | Deprecate the Pack200 Tools and API                          | ê¸°ëŠ¥ ê°œì„  |       |

**ì•Œì•„ ë‘ë©´ ì¢‹ì€ ê¸°ëŠ¥ë“¤**
- String í´ë˜ìŠ¤ì— ë©”ì†Œë“œ ì¶”ê°€
- File í´ë˜ìŠ¤ì— ë©”ì†Œë“œ ì¶”ê°€
- Collection ì¸í„°í˜ì´ìŠ¤ì— toArray() ë©”ì†Œë“œ ì¶”ê°€
- Predicate ì¸í„°í˜ì´ìŠ¤ì— not() ë©”ì†Œë“œ ì¶”ê°€
- Lambda ì‚¬ìš©ì‹œ var ë³€ìˆ˜ ì‚¬ìš© ê°€ëŠ¥
- HTTP Client í´ë˜ìŠ¤ ì¶”ê°€
- Nestmate ì ‘ê·¼ ì œì–´

**ê¸°ëŠ¥ ë³´ì™„ ë° ì œê±°**
- Dynamic Class-File Constants
- Improved Aarch64 Intrinsics
- A No-Op Garbage Collector
- Java EE/CORBA ì œê±°
- Nashorn ìë°”ìŠ¤í¬ë¦¼íŠ¸ ì—”ì§„, Pack200 íˆ´ deprecate

**JDK ì—ì„œ ë¶„ë¦¬ëœ ê¸°ëŠ¥ / íˆ´**
- Java Flight Recorder JDK ì—ì„œ ë¶„ë¦¬
- Java Mission Control JDK ì—ì„œ ë¶„ë¦¬
- JavaFX ëª¨íŠ¤ JDK ì—ì„œ ë¶„ë¦¬

**ê°€ì¥ í° ë³€ê²½ì‚¬í•­: 330ë²ˆ** 
- Launch Single-File Source-Code Programs
- java íŒŒì¼ì„ javac ì»´íŒŒì¼ ì—†ì´ ì‹¤í–‰


### âœ¨ ì»´íŒŒì¼ ì—†ì´ java íŒŒì¼ì˜ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì€?

```java
package f.java11;

public class NoCompile { 
	public static void main(String args[]) { 
		System.out.println("No compile run !!")
	}
}
```

```
$ java NoCompile.java
No compile run !!
```


```java
package f.java11;

import java.util.Arrays;

public class NoCompileWithArgs {
    public static void main(String args[]) {
        if(args.length>0) {
            Arrays.stream(args).forEach(System.out::println);
        } else {
            System.out.println("No arg is passed !");
        }
    }
}
```

```
$ java NoCompileWithArgs.java
No arg is passed !
```

```
$ java NoCompileWithArgs.java God of java
God
of
java
```

- Java 11ë¶€í„°ëŠ” ì»´íŒŒì¼ ì—†ì´ ìë°” ì½”ë“œë¥¼ ì§ì ‘ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤
- ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì€ "shebang" íŒŒì¼ì´ë¼ê³  ë¶€ë¥´ë©°, "#"ì˜ sharpì™€ "!"ì˜ bangì„ í•©ì³ì„œ ëª…ëª…ë˜ì—ˆìŠµë‹ˆë‹¤
- ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì´ ë˜ë ¤ë©´ ì²« ë²ˆì§¸ ì¤„ì´ "#!"ë¡œ ì‹œì‘í•´ì•¼ í•˜ê³ , ì‹¤í–‰ íŒŒì¼ë¡œ ì •ì˜ë˜ì–´ì•¼ í•©ë‹ˆë‹¤
- íŒŒì¼ì˜ ê°€ì¥ ì• ë¶€ë¶„ì´ "#!java"ë¡œ ì‹œì‘í•˜ë©´ ë©ë‹ˆë‹¤
- Javaê°€ PATHì— í¬í•¨ë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ "#!/usr/bin/java"ì™€ ê°™ì´ ì ˆëŒ€ ê²½ë¡œë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤
- Java 11 ì´ìƒì„ì„ ëª…ì‹œí•˜ê¸° ìœ„í•´ì„œëŠ” "--source 11" ì˜µì…˜ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤
- Java 11ë¶€í„°ëŠ” bashë‚˜ csh ê°™ì€ ì…¸ ìŠ¤í¬ë¦½íŠ¸ì²˜ëŸ¼ ìë°” ì½”ë“œë¥¼ ìŠ¤í¬ë¦½íŠ¸ í˜•íƒœë¡œ ì§ì ‘ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œ ë˜ì–´, ê°œë°œí•  ë•Œ í•„ìš”í•œ ê¸°ëŠ¥ë“¤ì„ ë” ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.


### âœ¨ Lambda ì—ì„œ var ì‚¬ìš©í•´ë³´ê¸°

```java
import java.util.Arrays;
import java.util.List;
import java.util.function.BinaryOperator;

public class SumExamples {
    
    // Method 1: Anonymous class implementation
    private void getSum1() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        BinaryOperator<Integer> sumNumber = new BinaryOperator<Integer>() {
            @Override
            public Integer apply(Integer x, Integer y) {
                return x + y;
            }
        };
        
        int sum = numbers.stream().reduce(0, sumNumber);
        System.out.println("array sum 1 is " + sum);
    }
    
    // Method 2: Lambda expression with explicit types
    private void getSum2() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        BinaryOperator<Integer> sumNumber = (Integer x, Integer y) -> x+y;
        
        int sum = numbers.stream().reduce(0, sumNumber);
        System.out.println("array sum 2 is " + sum);
    }
    
    // Method 3: Lambda expression with var keyword
    private void getSum3() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        BinaryOperator<Integer> sumNumber = (var x, var y) -> x+y;
        
        int sum = numbers.stream().reduce(0, sumNumber);
        System.out.println("array sum 3 is " + sum);
    }
    
    // Method 4: Inline lambda expression with var keyword
    private void getSum4() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        int sum = numbers.stream().reduce(0, (var x, var y) -> x+y);
        System.out.println("array sum 4 is " + sum);
    }
}
```


## â›‘ï¸ ë³´ì¶© í•„ìš”
--- 